#' A 'ggplot2' geom to draw assembly scars
#'
#' `geom_assembly_scar()` draws a geom representing an assembly scar, the
#' nucleotide sequence that is left behind after some cloning methods such as
#' restriction and ligation.
#'
#' The assembly scar is drawn as two parallel lines offset outwards from the
#' molecular backbone. It has a fill between these lines which obscures the
#' backbone. This fill is white by default, but may need to be changed to match
#' the background colour of the plot.
#'
#' The position of the assembly scar on the molecular backbone is set with the
#' `xmin` and `xmax` aesthetics. The molecular backbone that it is associated
#' with is set with the `y` aesthetic. This geom does not accept a forward
#' aesthetic, as it is not associated with a particular strand.
#'
#' @section Aesthetics:
#'
#' - xmin,xmax (required; start and end positions of the assembly scar)
#' - y (required; the molecular backbone)
#' - forward
#' - alpha
#' - colour
#' - linetype
#' - size
#' - fill
#'
#' @param mapping,data,stat,position,na.rm,show.legend,inherit.aes,... As
#' standard for ggplot2. inherit.aes is set to FALSE by default.
#' @param height `grid::unit()` object giving the height that the assembly scar
#' extends away from the molecular backbone. Defaults to 5 mm. 
#'
#' @examples
#'
#' ggplot2::ggplot(feature_garden[feature_garden$feature == "assembly_scar", ],
#'                 ggplot2::aes(xmin = start, xmax = end, y = molecule)) +
#'   geom_assembly_scar(inherit.aes = TRUE)
#'
#' @seealso [geom_assembly_scar_label()]
#'
#' @export
geom_assembly_scar <- function(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = FALSE,
  height = grid::unit(5, "mm"),
  ...
) {
  ggplot2::layer(
    geom = GeomAssemblyScar,
    mapping = mapping,
    data = data,
    stat = stat,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      na.rm = na.rm,
      height = height,
      ...
    ) 
  )
}

#' GeomAssemblyScar
#' @noRd
GeomAssemblyScar <- ggplot2::ggproto("GeomAssemblyScar", ggplot2::Geom,
  required_aes = c("xmin", "xmax", "y"),
  default_aes = ggplot2::aes(
    forward = TRUE,
    alpha = 1,
    colour = "black",
    linetype = 1,
    size = 1,
    fill = "white"
  ),

  draw_key = ggplot2::draw_key_abline,

  setup_data = function(data, params) {
    data
  },

  setup_params = function(data, params) {

    # Height should not be negative
    if (as.numeric(params$height) < 0) {
      cli::cli_abort("{.arg height} argument to {.fun geom_assembly_scar} cannot be negative") 
    }

    params
  },

  draw_panel = function(data, panel_scales, coord, height) {

    # Detect coordinate system and transform values
    coord_system <- get_coord_system(coord)
    data <- data_to_grid(data, coord_system, panel_scales, coord)

    gt <- grid::gTree(
      data = data,
      cl = "assemblyscartree",
      height = height,
      coord_system = coord_system
    )
    gt$name <- grid::grobName(gt, "geom_assembly_scar")
    gt
  }
)

#' @importFrom grid makeContent
#' @export
makeContent.assemblyscartree <- function(x) {

  data <- x$data

  # Prepare grob for each assembly scar
  grobs <- lapply(seq_len(nrow(data)), function(i) {

    assembly_scar <- data[i, ]

    # Set up geometry
    r <- ifelse(x$coord_system == "polar", assembly_scar$away, NA)
    awayness <- unit_to_alaw(x$height, "away", x$coord_system, r) 

    # Generate the polyline and polygon. assembly_scar_alongs and
    # assembly_scar_aways are internal data generated by
    # data-raw/prepare_coordinates.R
    alongs_polyline <- c(assembly_scar$along_min, assembly_scar$along_max,
                assembly_scar$along_max, assembly_scar$along_min)
    aways_polyline <- assembly_scar$away + (awayness * assembly_scar_aways)
    ids_polyline <- c(1, 1, 2, 2)
    alongs_polygon <- alongs_polyline
    aways_polygon <- aways_polyline

    # If in polar coordinates, segment the polygon
    if (x$coord_system == "polar") {
      segmented_polyline <- segment_polarline(alongs_polyline, 
                                              aways_polyline, ids_polyline)
      alongs_polyline <- segmented_polyline$thetas
      aways_polyline <- segmented_polyline$rs
      ids_polyline <- segmented_polyline$ids

      segmented_polygon <- segment_polarline(alongs_polygon, aways_polygon)
      alongs_polygon <- segmented_polygon$thetas
      aways_polygon <- segmented_polygon$rs
    }

    # Convert polyline and polygon into Cartesian coordinates within the grid
    # viewport
    coords_polyline <- alaw_to_grid(alongs_polyline, aways_polyline,
                                    x$coord_system, r)
    coords_polygon <- alaw_to_grid(alongs_polygon, aways_polygon,
                                   x$coord_system, r)

    # Generate polyline and polygon grobs for the assembly_scar
    polyline_grob <- grid::polylineGrob(
      x = coords_polyline$x,
      y = coords_polyline$y,
      id = ids_polyline,
      gp = grid::gpar(
        col = assembly_scar$colour,
        lty = assembly_scar$linetype,
        lwd = assembly_scar$size
      )
    )
    polygon_grob <- grid::polygonGrob(
      x = coords_polygon$x,
      y = coords_polygon$y,
      gp = grid::gpar(
        col = NA,
        fill = assembly_scar$fill
      )
    )

    # Return the gTree
    grobTree(polygon_grob, polyline_grob)
  })

  class(grobs) <- "gList"
  grid::setChildren(x, grobs)
}
