#' A 'ggplot2' geom to draw aptamers
#'
#' `geom_aptamer()` draws a geom representing an aptamer, a short
#' polynucleotide or polypeptide sequence that binds a target molecule.
#'
#' The aptamer is drawn as a stylised secondary structure of a short
#' polynucleotide. It has an internal fill, which is white by default.
#'
#' The position of the aptamer on the molecular backbone is set with the `x`
#' aesthetic. The molecular backbone that it is associated with is set with the
#' `y` aesthetic. The `forward` aesthetic can be used to set whether the
#' aptamer is on the forward (default) or reverse strand.
#'
#' @section Variant forms:
#'
#' - default: the default form
#' - reverse_above: aptamers on the reverse strand will be drawn above the
#' molecular backbone, but will still be flipped horizontally
#'
#' @section Aesthetics:
#'
#' - x (required; position of the aptamer)
#' - y (required; the molecular backbone)
#' - forward
#' - alpha
#' - colour
#' - linetype
#' - size
#' - fill
#'
#' @param variant Specify a variant form of the geom (see section Variant
#' forms).
#' @param mapping,data,stat,position,na.rm,show.legend,inherit.aes,... As
#' standard for ggplot2. inherit.aes is set to FALSE by default.
#' @param height `grid::unit()` opbject giving the height of the aptamer above
#' the molecular backbone. Defaults to 5 mm. The aspect ratio of the aptamer is
#' fixed, so the width of the geom will be equal to the height.
#'
#' @examples
#'
#' ggplot2::ggplot(example_SBOL_features[example_SBOL_features$type == "aptamer", ],
#'                 ggplot2::aes(x = start, y = molecule)) +
#'   geom_aptamer(inherit.aes = TRUE)
#'
#' @seealso [geom_aptamer_label()]
#'
#' @export
geom_aptamer <- function(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = FALSE,
  height = grid::unit(5, "mm"),
  variant = "default",
  ...
) {
  ggplot2::layer(
    geom = GeomAptamer,
    mapping = mapping,
    data = data,
    stat = stat,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      na.rm = na.rm,
      height = height,
      variant = variant,
      ...
    ) 
  )
}

#' GeomAptamer
#' @noRd
GeomAptamer <- ggplot2::ggproto("GeomAptamer", ggplot2::Geom,
  required_aes = c("x", "y"),
  default_aes = ggplot2::aes(
    forward = TRUE,
    alpha = 1,
    colour = "black",
    linetype = 1,
    size = 1,
    fill = "white"
  ),

  draw_key = ggplot2::draw_key_abline,

  setup_data = function(data, params) {
    data
  },

  setup_params = function(data, params) {

    # Height should not be negative
    if (as.numeric(params$height) < 0) {
      cli::cli_abort("{.arg height} argument to {.fun geom_aptamer} cannot be negative") 
    }

    # Check that variant is valid
    if (! params$variant %in% c("default", "reverse_above")) {
      cli::cli_abort("{.val {params$variant}} is not a valid value for {.arg variant} in {.fun geom_aptamer}")
    }

    params
  },

  draw_panel = function(data, panel_scales, coord, height, variant) {

    # Detect coordinate system and transform values
    coord_system <- get_coord_system(coord)
    data <- data_to_grid(data, coord_system, panel_scales, coord)

    gt <- grid::gTree(
      data = data,
      cl = "aptamertree",
      height = height,
      variant = variant,
      coord_system = coord_system
    )
    gt$name <- grid::grobName(gt, "geom_aptamer")
    gt
  }
)

#' @importFrom grid makeContent
#' @export
makeContent.aptamertree <- function(x) {

  data <- x$data

  # Prepare grob for each aptamer
  grobs <- lapply(seq_len(nrow(data)), function(i) {

    aptamer <- data[i, ]

    # Set up geometry
    r <- ifelse(x$coord_system == "polar", aptamer$away, NA)
    awayness <- unit_to_alaw(x$height, "away", x$coord_system, r) 
    alongness <- unit_to_alaw(x$height, "along", x$coord_system, r)

    # If on the reverse strand, invert the glyph horizontally and/or vertically
    # as appropriate for the variant
    if (! aptamer$forward) {

      if (x$variant == "default") {
        aptamer_alongs <- 0 - aptamer_alongs
        aptamer_aways <- 0 - aptamer_aways

      } else if (x$variant == "reverse_above") {
        aptamer_alongs <- 0 - aptamer_alongs
      }
    }

    # Generate the polygon. The grob is drawn such that the 'stalk' of the
    # aptamer is centred on the along coordinate. aptamer_alongs and
    # aptamer_aways are internal data generated by
    # data-raw/prepare_coordinates.R
    alongs <- aptamer$along + (alongness * aptamer_alongs)
    aways <- aptamer$away + (awayness * aptamer_aways)

    # If in polar coordinates, segment the polygon
    if (x$coord_system == "polar") {
      segmented <- segment_polargon(alongs, aways)
      alongs <- segmented$thetas
      aways <- segmented$rs
    }

    # Convert polygon into Cartesian coordinates within the grid viewport
    coords <- alaw_to_grid(alongs, aways, x$coord_system, r)

    # Generate polygon grob for the aptamer
    pg <- grid::polygonGrob(
      x = coords$x,
      y = coords$y,
      gp = grid::gpar(
        col = aptamer$colour,
        fill = aptamer$fill,
        lty = aptamer$linetype,
        lwd = aptamer$size
      )
    )

    # Return the grob
    pg
  })

  class(grobs) <- "gList"
  grid::setChildren(x, grobs)
}
